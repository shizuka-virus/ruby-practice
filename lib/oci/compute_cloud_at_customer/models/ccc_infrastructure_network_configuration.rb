# Copyright (c) 2016, 2024, Oracle and/or its affiliates.  All rights reserved.
# This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.

# NOTE: This class is auto generated by OracleSDKGenerator. DO NOT EDIT. API Version: 20221208
require 'date'
require 'logger'

# rubocop:disable Lint/UnneededCopDisableDirective, Metrics/LineLength
module OCI
  # Configuration information for the Compute Cloud@Customer infrastructure. This
  # network configuration information cannot be updated and is retrieved from the data center.
  # The information will only be available
  # after the connectionState is transitioned to CONNECTED.
  #
  class ComputeCloudAtCustomer::Models::CccInfrastructureNetworkConfiguration
    UPLINK_PORT_FORWARD_ERROR_CORRECTION_ENUM = [
      UPLINK_PORT_FORWARD_ERROR_CORRECTION_AUTO = 'AUTO'.freeze,
      UPLINK_PORT_FORWARD_ERROR_CORRECTION_FIRE_CODE_FEC = 'FIRE_CODE_FEC'.freeze,
      UPLINK_PORT_FORWARD_ERROR_CORRECTION_REED_SOLOMON_CONSORTIUM_16 = 'REED_SOLOMON_CONSORTIUM_16'.freeze,
      UPLINK_PORT_FORWARD_ERROR_CORRECTION_REED_SOLOMON_FEC = 'REED_SOLOMON_FEC'.freeze,
      UPLINK_PORT_FORWARD_ERROR_CORRECTION_REED_SOLOMON_IEEE = 'REED_SOLOMON_IEEE'.freeze,
      UPLINK_PORT_FORWARD_ERROR_CORRECTION_UNKNOWN_ENUM_VALUE = 'UNKNOWN_ENUM_VALUE'.freeze
    ].freeze

    # Information about the management nodes that are provisioned in the Compute Cloud@Customer
    # infrastructure.
    #
    # @return [Array<OCI::ComputeCloudAtCustomer::Models::CccInfrastructureManagementNode>]
    attr_accessor :management_nodes

    # Uplink port speed defined in gigabytes per second.
    # All uplink ports must have identical speed.
    #
    # @return [Integer]
    attr_accessor :uplink_port_speed_in_gbps

    # Number of uplink ports per spine switch. Connectivity is identical on both spine switches.
    # For example, if input is two 100 gigabyte ports; then port-1 and port-2 on both spines will be configured.
    #
    # @return [Integer]
    attr_accessor :uplink_port_count

    # The virtual local area network (VLAN) maximum transmission unit (MTU) size
    # for the uplink ports.
    #
    # @return [Integer]
    attr_accessor :uplink_vlan_mtu

    # Netmask of the subnet that the Compute Cloud@Customer infrastructure is
    # connected to.
    #
    # @return [String]
    attr_accessor :uplink_netmask

    # The port forward error correction (FEC) setting for the uplink port on the
    # Compute Cloud@Customer infrastructure.
    #
    # @return [String]
    attr_reader :uplink_port_forward_error_correction

    # Domain name to be used as the base domain for the internal network and by
    # public facing services.
    #
    # @return [String]
    attr_accessor :uplink_domain

    # Uplink gateway in the datacenter network that the Compute Cloud@Customer
    # connects to.
    #
    # @return [String]
    attr_accessor :uplink_gateway_ip

    # Addresses of the network spine switches.
    # @return [Array<String>]
    attr_accessor :spine_ips

    # The spine switch public virtual IP (VIP). Traffic routed to the
    # Compute Cloud@Customer infrastructure and
    # and virtual cloud networks (VCNs) should have this address as next hop.
    #
    # @return [String]
    attr_accessor :spine_vip

    # The hostname corresponding to the virtual IP (VIP) address of the management nodes.
    #
    # @return [String]
    attr_accessor :mgmt_vip_hostname

    # The IP address used as the virtual IP (VIP) address of the management nodes.
    # @return [String]
    attr_accessor :mgmt_vip_ip

    # The domain name system (DNS) addresses that the Compute Cloud@Customer infrastructure
    # uses for the data center network.
    #
    # @return [Array<String>]
    attr_accessor :dns_ips

    # @return [OCI::ComputeCloudAtCustomer::Models::CccInfrastructureRoutingStaticDetails]
    attr_accessor :infrastructure_routing_static

    # @return [OCI::ComputeCloudAtCustomer::Models::CccInfrastructureRoutingDynamicDetails]
    attr_accessor :infrastructure_routing_dynamic

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        # rubocop:disable Style/SymbolLiteral
        'management_nodes': :'managementNodes',
        'uplink_port_speed_in_gbps': :'uplinkPortSpeedInGbps',
        'uplink_port_count': :'uplinkPortCount',
        'uplink_vlan_mtu': :'uplinkVlanMtu',
        'uplink_netmask': :'uplinkNetmask',
        'uplink_port_forward_error_correction': :'uplinkPortForwardErrorCorrection',
        'uplink_domain': :'uplinkDomain',
        'uplink_gateway_ip': :'uplinkGatewayIp',
        'spine_ips': :'spineIps',
        'spine_vip': :'spineVip',
        'mgmt_vip_hostname': :'mgmtVipHostname',
        'mgmt_vip_ip': :'mgmtVipIp',
        'dns_ips': :'dnsIps',
        'infrastructure_routing_static': :'infrastructureRoutingStatic',
        'infrastructure_routing_dynamic': :'infrastructureRoutingDynamic'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        # rubocop:disable Style/SymbolLiteral
        'management_nodes': :'Array<OCI::ComputeCloudAtCustomer::Models::CccInfrastructureManagementNode>',
        'uplink_port_speed_in_gbps': :'Integer',
        'uplink_port_count': :'Integer',
        'uplink_vlan_mtu': :'Integer',
        'uplink_netmask': :'String',
        'uplink_port_forward_error_correction': :'String',
        'uplink_domain': :'String',
        'uplink_gateway_ip': :'String',
        'spine_ips': :'Array<String>',
        'spine_vip': :'String',
        'mgmt_vip_hostname': :'String',
        'mgmt_vip_ip': :'String',
        'dns_ips': :'Array<String>',
        'infrastructure_routing_static': :'OCI::ComputeCloudAtCustomer::Models::CccInfrastructureRoutingStaticDetails',
        'infrastructure_routing_dynamic': :'OCI::ComputeCloudAtCustomer::Models::CccInfrastructureRoutingDynamicDetails'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:disable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral


    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    # @option attributes [Array<OCI::ComputeCloudAtCustomer::Models::CccInfrastructureManagementNode>] :management_nodes The value to assign to the {#management_nodes} property
    # @option attributes [Integer] :uplink_port_speed_in_gbps The value to assign to the {#uplink_port_speed_in_gbps} property
    # @option attributes [Integer] :uplink_port_count The value to assign to the {#uplink_port_count} property
    # @option attributes [Integer] :uplink_vlan_mtu The value to assign to the {#uplink_vlan_mtu} property
    # @option attributes [String] :uplink_netmask The value to assign to the {#uplink_netmask} property
    # @option attributes [String] :uplink_port_forward_error_correction The value to assign to the {#uplink_port_forward_error_correction} property
    # @option attributes [String] :uplink_domain The value to assign to the {#uplink_domain} property
    # @option attributes [String] :uplink_gateway_ip The value to assign to the {#uplink_gateway_ip} property
    # @option attributes [Array<String>] :spine_ips The value to assign to the {#spine_ips} property
    # @option attributes [String] :spine_vip The value to assign to the {#spine_vip} property
    # @option attributes [String] :mgmt_vip_hostname The value to assign to the {#mgmt_vip_hostname} property
    # @option attributes [String] :mgmt_vip_ip The value to assign to the {#mgmt_vip_ip} property
    # @option attributes [Array<String>] :dns_ips The value to assign to the {#dns_ips} property
    # @option attributes [OCI::ComputeCloudAtCustomer::Models::CccInfrastructureRoutingStaticDetails] :infrastructure_routing_static The value to assign to the {#infrastructure_routing_static} property
    # @option attributes [OCI::ComputeCloudAtCustomer::Models::CccInfrastructureRoutingDynamicDetails] :infrastructure_routing_dynamic The value to assign to the {#infrastructure_routing_dynamic} property
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

      self.management_nodes = attributes[:'managementNodes'] if attributes[:'managementNodes']

      raise 'You cannot provide both :managementNodes and :management_nodes' if attributes.key?(:'managementNodes') && attributes.key?(:'management_nodes')

      self.management_nodes = attributes[:'management_nodes'] if attributes[:'management_nodes']

      self.uplink_port_speed_in_gbps = attributes[:'uplinkPortSpeedInGbps'] if attributes[:'uplinkPortSpeedInGbps']

      raise 'You cannot provide both :uplinkPortSpeedInGbps and :uplink_port_speed_in_gbps' if attributes.key?(:'uplinkPortSpeedInGbps') && attributes.key?(:'uplink_port_speed_in_gbps')

      self.uplink_port_speed_in_gbps = attributes[:'uplink_port_speed_in_gbps'] if attributes[:'uplink_port_speed_in_gbps']

      self.uplink_port_count = attributes[:'uplinkPortCount'] if attributes[:'uplinkPortCount']

      raise 'You cannot provide both :uplinkPortCount and :uplink_port_count' if attributes.key?(:'uplinkPortCount') && attributes.key?(:'uplink_port_count')

      self.uplink_port_count = attributes[:'uplink_port_count'] if attributes[:'uplink_port_count']

      self.uplink_vlan_mtu = attributes[:'uplinkVlanMtu'] if attributes[:'uplinkVlanMtu']

      raise 'You cannot provide both :uplinkVlanMtu and :uplink_vlan_mtu' if attributes.key?(:'uplinkVlanMtu') && attributes.key?(:'uplink_vlan_mtu')

      self.uplink_vlan_mtu = attributes[:'uplink_vlan_mtu'] if attributes[:'uplink_vlan_mtu']

      self.uplink_netmask = attributes[:'uplinkNetmask'] if attributes[:'uplinkNetmask']

      raise 'You cannot provide both :uplinkNetmask and :uplink_netmask' if attributes.key?(:'uplinkNetmask') && attributes.key?(:'uplink_netmask')

      self.uplink_netmask = attributes[:'uplink_netmask'] if attributes[:'uplink_netmask']

      self.uplink_port_forward_error_correction = attributes[:'uplinkPortForwardErrorCorrection'] if attributes[:'uplinkPortForwardErrorCorrection']
      self.uplink_port_forward_error_correction = "AUTO" if uplink_port_forward_error_correction.nil? && !attributes.key?(:'uplinkPortForwardErrorCorrection') # rubocop:disable Style/StringLiterals

      raise 'You cannot provide both :uplinkPortForwardErrorCorrection and :uplink_port_forward_error_correction' if attributes.key?(:'uplinkPortForwardErrorCorrection') && attributes.key?(:'uplink_port_forward_error_correction')

      self.uplink_port_forward_error_correction = attributes[:'uplink_port_forward_error_correction'] if attributes[:'uplink_port_forward_error_correction']
      self.uplink_port_forward_error_correction = "AUTO" if uplink_port_forward_error_correction.nil? && !attributes.key?(:'uplinkPortForwardErrorCorrection') && !attributes.key?(:'uplink_port_forward_error_correction') # rubocop:disable Style/StringLiterals

      self.uplink_domain = attributes[:'uplinkDomain'] if attributes[:'uplinkDomain']

      raise 'You cannot provide both :uplinkDomain and :uplink_domain' if attributes.key?(:'uplinkDomain') && attributes.key?(:'uplink_domain')

      self.uplink_domain = attributes[:'uplink_domain'] if attributes[:'uplink_domain']

      self.uplink_gateway_ip = attributes[:'uplinkGatewayIp'] if attributes[:'uplinkGatewayIp']

      raise 'You cannot provide both :uplinkGatewayIp and :uplink_gateway_ip' if attributes.key?(:'uplinkGatewayIp') && attributes.key?(:'uplink_gateway_ip')

      self.uplink_gateway_ip = attributes[:'uplink_gateway_ip'] if attributes[:'uplink_gateway_ip']

      self.spine_ips = attributes[:'spineIps'] if attributes[:'spineIps']

      raise 'You cannot provide both :spineIps and :spine_ips' if attributes.key?(:'spineIps') && attributes.key?(:'spine_ips')

      self.spine_ips = attributes[:'spine_ips'] if attributes[:'spine_ips']

      self.spine_vip = attributes[:'spineVip'] if attributes[:'spineVip']

      raise 'You cannot provide both :spineVip and :spine_vip' if attributes.key?(:'spineVip') && attributes.key?(:'spine_vip')

      self.spine_vip = attributes[:'spine_vip'] if attributes[:'spine_vip']

      self.mgmt_vip_hostname = attributes[:'mgmtVipHostname'] if attributes[:'mgmtVipHostname']

      raise 'You cannot provide both :mgmtVipHostname and :mgmt_vip_hostname' if attributes.key?(:'mgmtVipHostname') && attributes.key?(:'mgmt_vip_hostname')

      self.mgmt_vip_hostname = attributes[:'mgmt_vip_hostname'] if attributes[:'mgmt_vip_hostname']

      self.mgmt_vip_ip = attributes[:'mgmtVipIp'] if attributes[:'mgmtVipIp']

      raise 'You cannot provide both :mgmtVipIp and :mgmt_vip_ip' if attributes.key?(:'mgmtVipIp') && attributes.key?(:'mgmt_vip_ip')

      self.mgmt_vip_ip = attributes[:'mgmt_vip_ip'] if attributes[:'mgmt_vip_ip']

      self.dns_ips = attributes[:'dnsIps'] if attributes[:'dnsIps']

      raise 'You cannot provide both :dnsIps and :dns_ips' if attributes.key?(:'dnsIps') && attributes.key?(:'dns_ips')

      self.dns_ips = attributes[:'dns_ips'] if attributes[:'dns_ips']

      self.infrastructure_routing_static = attributes[:'infrastructureRoutingStatic'] if attributes[:'infrastructureRoutingStatic']

      raise 'You cannot provide both :infrastructureRoutingStatic and :infrastructure_routing_static' if attributes.key?(:'infrastructureRoutingStatic') && attributes.key?(:'infrastructure_routing_static')

      self.infrastructure_routing_static = attributes[:'infrastructure_routing_static'] if attributes[:'infrastructure_routing_static']

      self.infrastructure_routing_dynamic = attributes[:'infrastructureRoutingDynamic'] if attributes[:'infrastructureRoutingDynamic']

      raise 'You cannot provide both :infrastructureRoutingDynamic and :infrastructure_routing_dynamic' if attributes.key?(:'infrastructureRoutingDynamic') && attributes.key?(:'infrastructure_routing_dynamic')

      self.infrastructure_routing_dynamic = attributes[:'infrastructure_routing_dynamic'] if attributes[:'infrastructure_routing_dynamic']
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:enable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] uplink_port_forward_error_correction Object to be assigned
    def uplink_port_forward_error_correction=(uplink_port_forward_error_correction)
      # rubocop:disable Style/ConditionalAssignment
      if uplink_port_forward_error_correction && !UPLINK_PORT_FORWARD_ERROR_CORRECTION_ENUM.include?(uplink_port_forward_error_correction)
        OCI.logger.debug("Unknown value for 'uplink_port_forward_error_correction' [" + uplink_port_forward_error_correction + "]. Mapping to 'UPLINK_PORT_FORWARD_ERROR_CORRECTION_UNKNOWN_ENUM_VALUE'") if OCI.logger
        @uplink_port_forward_error_correction = UPLINK_PORT_FORWARD_ERROR_CORRECTION_UNKNOWN_ENUM_VALUE
      else
        @uplink_port_forward_error_correction = uplink_port_forward_error_correction
      end
      # rubocop:enable Style/ConditionalAssignment
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines


    # Checks equality by comparing each attribute.
    # @param [Object] other the other object to be compared
    def ==(other)
      return true if equal?(other)

      self.class == other.class &&
        management_nodes == other.management_nodes &&
        uplink_port_speed_in_gbps == other.uplink_port_speed_in_gbps &&
        uplink_port_count == other.uplink_port_count &&
        uplink_vlan_mtu == other.uplink_vlan_mtu &&
        uplink_netmask == other.uplink_netmask &&
        uplink_port_forward_error_correction == other.uplink_port_forward_error_correction &&
        uplink_domain == other.uplink_domain &&
        uplink_gateway_ip == other.uplink_gateway_ip &&
        spine_ips == other.spine_ips &&
        spine_vip == other.spine_vip &&
        mgmt_vip_hostname == other.mgmt_vip_hostname &&
        mgmt_vip_ip == other.mgmt_vip_ip &&
        dns_ips == other.dns_ips &&
        infrastructure_routing_static == other.infrastructure_routing_static &&
        infrastructure_routing_dynamic == other.infrastructure_routing_dynamic
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines

    # @see the `==` method
    # @param [Object] other the other object to be compared
    def eql?(other)
      self == other
    end

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [management_nodes, uplink_port_speed_in_gbps, uplink_port_count, uplink_vlan_mtu, uplink_netmask, uplink_port_forward_error_correction, uplink_domain, uplink_gateway_ip, spine_ips, spine_vip, mgmt_vip_hostname, mgmt_vip_ip, dns_ips, infrastructure_routing_static, infrastructure_routing_dynamic].hash
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)

      self.class.swagger_types.each_pair do |key, type|
        if type =~ /^Array<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            public_method("#{key}=").call(
              attributes[self.class.attribute_map[key]]
                .map { |v| OCI::Internal::Util.convert_to_type(Regexp.last_match(1), v) }
            )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          public_method("#{key}=").call(
            OCI::Internal::Util.convert_to_type(type, attributes[self.class.attribute_map[key]])
          )
        end
        # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = public_method(attr).call
        next if value.nil? && !instance_variable_defined?("@#{attr}")

        hash[param] = _to_hash(value)
      end
      hash
    end

    private

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
# rubocop:enable Lint/UnneededCopDisableDirective, Metrics/LineLength
