# Copyright (c) 2016, 2024, Oracle and/or its affiliates.  All rights reserved.
# This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.

# NOTE: This class is auto generated by OracleSDKGenerator. DO NOT EDIT. API Version: 20200131

# rubocop:disable Lint/UnneededCopDisableDirective, Metrics/LineLength
module OCI
  # This class provides a wrapper around {OCI::CloudGuard::CloudGuardClient} and offers convenience methods
  # for operations that would otherwise need to be chained together. For example, instead of performing an action
  # on a resource (e.g. launching an instance, creating a load balancer) and then using a waiter to wait for the resource
  # to enter a given state, you can call a single method in this class to accomplish the same functionality
  class CloudGuard::CloudGuardClientCompositeOperations
    # The {OCI::CloudGuard::CloudGuardClient} used to communicate with the service_client
    #
    # @return [OCI::CloudGuard::CloudGuardClient]
    attr_reader :service_client

    # Initializes a new CloudGuardClientCompositeOperations
    #
    # @param [OCI::CloudGuard::CloudGuardClient] service_client The client used to communicate with the service.
    #   Defaults to a new service client created via {OCI::CloudGuard::CloudGuardClient#initialize} with no arguments
    def initialize(service_client = OCI::CloudGuard::CloudGuardClient.new)
      @service_client = service_client
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#add_compartment} and then waits for the {OCI::CloudGuard::Models::SecurityZone} acted upon
    # to enter the given state(s).
    #
    # @param [String] security_zone_id The unique identifier of the security zone (`SecurityZone` resource).
    # @param [OCI::CloudGuard::Models::AddCompartmentDetails] add_compartment_details Parameters for an existing compartment to be added to a security zone
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::SecurityZone#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#add_compartment}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::SecurityZone}
    def add_compartment_and_wait_for_state(security_zone_id, add_compartment_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.add_compartment(security_zone_id, add_compartment_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_security_zone(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#change_data_source_compartment} and then waits for the {OCI::CloudGuard::Models::WorkRequest}
    # to enter the given state(s).
    #
    # @param [String] data_source_id Data source OCID.
    # @param [OCI::CloudGuard::Models::ChangeDataSourceCompartmentDetails] change_data_source_compartment_details The compartment OCID of the DataSource resource
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::WorkRequest#status}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#change_data_source_compartment}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object containing the completed {OCI::CloudGuard::Models::WorkRequest}
    def change_data_source_compartment_and_wait_for_state(data_source_id, change_data_source_compartment_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.change_data_source_compartment(data_source_id, change_data_source_compartment_details, base_operation_opts)
      use_util = OCI::CloudGuard::Util.respond_to?(:wait_on_work_request)

      return operation_result if wait_for_states.empty? && !use_util

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.headers['opc-work-request-id']
      return operation_result if wait_for_resource_id.nil? || wait_for_resource_id.empty?

      begin
        if use_util
          waiter_result = OCI::CloudGuard::Util.wait_on_work_request(
            @service_client,
            wait_for_resource_id,
            max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
            max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
          )
        else
          waiter_result = @service_client.get_work_request(wait_for_resource_id).wait_until(
            eval_proc: ->(response) { response.data.respond_to?(:status) && lowered_wait_for_states.include?(response.data.status.downcase) },
            max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
            max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
          )
        end
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#create_adhoc_query} and then waits for the {OCI::CloudGuard::Models::AdhocQuery} acted upon
    # to enter the given state(s).
    #
    # @param [OCI::CloudGuard::Models::CreateAdhocQueryDetails] create_adhoc_query_details Details for the new AdhocQuery resource
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::AdhocQuery#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#create_adhoc_query}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::AdhocQuery}
    def create_adhoc_query_and_wait_for_state(create_adhoc_query_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.create_adhoc_query(create_adhoc_query_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_adhoc_query(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#create_data_mask_rule} and then waits for the {OCI::CloudGuard::Models::DataMaskRule} acted upon
    # to enter the given state(s).
    #
    # @param [OCI::CloudGuard::Models::CreateDataMaskRuleDetails] create_data_mask_rule_details Definition for the new data mask rule
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::DataMaskRule#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#create_data_mask_rule}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::DataMaskRule}
    def create_data_mask_rule_and_wait_for_state(create_data_mask_rule_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.create_data_mask_rule(create_data_mask_rule_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_data_mask_rule(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#create_data_source} and then waits for the {OCI::CloudGuard::Models::WorkRequest}
    # to enter the given state(s).
    #
    # @param [OCI::CloudGuard::Models::CreateDataSourceDetails] create_data_source_details Details for the new DataSource resource
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::WorkRequest#status}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#create_data_source}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object containing the completed {OCI::CloudGuard::Models::WorkRequest}
    def create_data_source_and_wait_for_state(create_data_source_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.create_data_source(create_data_source_details, base_operation_opts)
      use_util = OCI::CloudGuard::Util.respond_to?(:wait_on_work_request)

      return operation_result if wait_for_states.empty? && !use_util

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.headers['opc-work-request-id']
      return operation_result if wait_for_resource_id.nil? || wait_for_resource_id.empty?

      begin
        if use_util
          waiter_result = OCI::CloudGuard::Util.wait_on_work_request(
            @service_client,
            wait_for_resource_id,
            max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
            max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
          )
        else
          waiter_result = @service_client.get_work_request(wait_for_resource_id).wait_until(
            eval_proc: ->(response) { response.data.respond_to?(:status) && lowered_wait_for_states.include?(response.data.status.downcase) },
            max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
            max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
          )
        end
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#create_detector_recipe} and then waits for the {OCI::CloudGuard::Models::DetectorRecipe} acted upon
    # to enter the given state(s).
    #
    # @param [OCI::CloudGuard::Models::CreateDetectorRecipeDetails] create_detector_recipe_details Details for the new DetectorRecipe
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::DetectorRecipe#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#create_detector_recipe}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::DetectorRecipe}
    def create_detector_recipe_and_wait_for_state(create_detector_recipe_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.create_detector_recipe(create_detector_recipe_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_detector_recipe(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#create_detector_recipe_detector_rule} and then waits for the {OCI::CloudGuard::Models::DetectorRecipeDetectorRule} acted upon
    # to enter the given state(s).
    #
    # @param [String] detector_recipe_id Detector recipe OCID
    # @param [OCI::CloudGuard::Models::CreateDetectorRecipeDetectorRuleDetails] create_detector_recipe_detector_rule_details The details with which detector rule is to be created.
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::DetectorRecipeDetectorRule#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#create_detector_recipe_detector_rule}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::DetectorRecipeDetectorRule}
    def create_detector_recipe_detector_rule_and_wait_for_state(detector_recipe_id, create_detector_recipe_detector_rule_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.create_detector_recipe_detector_rule(detector_recipe_id, create_detector_recipe_detector_rule_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_detector_recipe_detector_rule(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#create_managed_list} and then waits for the {OCI::CloudGuard::Models::ManagedList} acted upon
    # to enter the given state(s).
    #
    # @param [OCI::CloudGuard::Models::CreateManagedListDetails] create_managed_list_details Details for the new ManagedList resources
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::ManagedList#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#create_managed_list}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::ManagedList}
    def create_managed_list_and_wait_for_state(create_managed_list_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.create_managed_list(create_managed_list_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_managed_list(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#create_responder_recipe} and then waits for the {OCI::CloudGuard::Models::ResponderRecipe} acted upon
    # to enter the given state(s).
    #
    # @param [OCI::CloudGuard::Models::CreateResponderRecipeDetails] create_responder_recipe_details Details for ResponderRecipe
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::ResponderRecipe#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#create_responder_recipe}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::ResponderRecipe}
    def create_responder_recipe_and_wait_for_state(create_responder_recipe_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.create_responder_recipe(create_responder_recipe_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_responder_recipe(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#create_saved_query} and then waits for the {OCI::CloudGuard::Models::SavedQuery} acted upon
    # to enter the given state(s).
    #
    # @param [OCI::CloudGuard::Models::CreateSavedQueryDetails] create_saved_query_details Details for the new SavedQuery resource
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::SavedQuery#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#create_saved_query}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::SavedQuery}
    def create_saved_query_and_wait_for_state(create_saved_query_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.create_saved_query(create_saved_query_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_saved_query(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#create_security_recipe} and then waits for the {OCI::CloudGuard::Models::SecurityRecipe} acted upon
    # to enter the given state(s).
    #
    # @param [OCI::CloudGuard::Models::CreateSecurityRecipeDetails] create_security_recipe_details Details for the new `SecurityRecipe` resource
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::SecurityRecipe#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#create_security_recipe}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::SecurityRecipe}
    def create_security_recipe_and_wait_for_state(create_security_recipe_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.create_security_recipe(create_security_recipe_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_security_recipe(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#create_security_zone} and then waits for the {OCI::CloudGuard::Models::SecurityZone} acted upon
    # to enter the given state(s).
    #
    # @param [OCI::CloudGuard::Models::CreateSecurityZoneDetails] create_security_zone_details Details for the new `SecurityZone` resource
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::SecurityZone#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#create_security_zone}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::SecurityZone}
    def create_security_zone_and_wait_for_state(create_security_zone_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.create_security_zone(create_security_zone_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_security_zone(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#create_target} and then waits for the {OCI::CloudGuard::Models::Target} acted upon
    # to enter the given state(s).
    #
    # @param [OCI::CloudGuard::Models::CreateTargetDetails] create_target_details Contains generic target information which is required for all target types
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::Target#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#create_target}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::Target}
    def create_target_and_wait_for_state(create_target_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.create_target(create_target_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_target(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#create_target_detector_recipe} and then waits for the {OCI::CloudGuard::Models::TargetDetectorRecipe} acted upon
    # to enter the given state(s).
    #
    # @param [String] target_id OCID of the target
    # @param [OCI::CloudGuard::Models::AttachTargetDetectorRecipeDetails] attach_target_detector_recipe_details Details for associating DetectorRecipe with Target
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::TargetDetectorRecipe#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#create_target_detector_recipe}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::TargetDetectorRecipe}
    def create_target_detector_recipe_and_wait_for_state(target_id, attach_target_detector_recipe_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.create_target_detector_recipe(target_id, attach_target_detector_recipe_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_target_detector_recipe(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#delete_adhoc_query} and then waits for the {OCI::CloudGuard::Models::AdhocQuery} acted upon
    # to enter the given state(s).
    #
    # @param [String] adhoc_query_id Adhoc query OCID.
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::AdhocQuery#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#delete_adhoc_query}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type nil
    def delete_adhoc_query_and_wait_for_state(adhoc_query_id, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      initial_get_result = @service_client.get_adhoc_query(adhoc_query_id)
      operation_result = @service_client.delete_adhoc_query(adhoc_query_id, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)

      begin
        waiter_result = initial_get_result.wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200,
          succeed_on_not_found: true
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#delete_data_mask_rule} and then waits for the {OCI::CloudGuard::Models::DataMaskRule} acted upon
    # to enter the given state(s).
    #
    # @param [String] data_mask_rule_id OCID of the data mask rule
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::DataMaskRule#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#delete_data_mask_rule}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type nil
    def delete_data_mask_rule_and_wait_for_state(data_mask_rule_id, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      initial_get_result = @service_client.get_data_mask_rule(data_mask_rule_id)
      operation_result = @service_client.delete_data_mask_rule(data_mask_rule_id, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)

      begin
        waiter_result = initial_get_result.wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200,
          succeed_on_not_found: true
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#delete_data_source} and then waits for the {OCI::CloudGuard::Models::WorkRequest}
    # to enter the given state(s).
    #
    # @param [String] data_source_id Data source OCID.
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::WorkRequest#status}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#delete_data_source}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object containing the completed {OCI::CloudGuard::Models::WorkRequest}
    def delete_data_source_and_wait_for_state(data_source_id, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.delete_data_source(data_source_id, base_operation_opts)
      use_util = OCI::CloudGuard::Util.respond_to?(:wait_on_work_request)

      return operation_result if wait_for_states.empty? && !use_util

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.headers['opc-work-request-id']
      return operation_result if wait_for_resource_id.nil? || wait_for_resource_id.empty?

      begin
        if use_util
          waiter_result = OCI::CloudGuard::Util.wait_on_work_request(
            @service_client,
            wait_for_resource_id,
            max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
            max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
          )
        else
          waiter_result = @service_client.get_work_request(wait_for_resource_id).wait_until(
            eval_proc: ->(response) { response.data.respond_to?(:status) && lowered_wait_for_states.include?(response.data.status.downcase) },
            max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
            max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
          )
        end
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#delete_detector_recipe} and then waits for the {OCI::CloudGuard::Models::DetectorRecipe} acted upon
    # to enter the given state(s).
    #
    # @param [String] detector_recipe_id Detector recipe OCID
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::DetectorRecipe#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#delete_detector_recipe}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type nil
    def delete_detector_recipe_and_wait_for_state(detector_recipe_id, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      initial_get_result = @service_client.get_detector_recipe(detector_recipe_id)
      operation_result = @service_client.delete_detector_recipe(detector_recipe_id, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)

      begin
        waiter_result = initial_get_result.wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200,
          succeed_on_not_found: true
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#delete_managed_list} and then waits for the {OCI::CloudGuard::Models::ManagedList} acted upon
    # to enter the given state(s).
    #
    # @param [String] managed_list_id The managed list OCID to be passed in the request.
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::ManagedList#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#delete_managed_list}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type nil
    def delete_managed_list_and_wait_for_state(managed_list_id, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      initial_get_result = @service_client.get_managed_list(managed_list_id)
      operation_result = @service_client.delete_managed_list(managed_list_id, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)

      begin
        waiter_result = initial_get_result.wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200,
          succeed_on_not_found: true
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#delete_responder_recipe} and then waits for the {OCI::CloudGuard::Models::ResponderRecipe} acted upon
    # to enter the given state(s).
    #
    # @param [String] responder_recipe_id OCID of the responder recipe.
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::ResponderRecipe#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#delete_responder_recipe}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type nil
    def delete_responder_recipe_and_wait_for_state(responder_recipe_id, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      initial_get_result = @service_client.get_responder_recipe(responder_recipe_id)
      operation_result = @service_client.delete_responder_recipe(responder_recipe_id, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)

      begin
        waiter_result = initial_get_result.wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200,
          succeed_on_not_found: true
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#delete_saved_query} and then waits for the {OCI::CloudGuard::Models::SavedQuery} acted upon
    # to enter the given state(s).
    #
    # @param [String] saved_query_id Saved query OCID
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::SavedQuery#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#delete_saved_query}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type nil
    def delete_saved_query_and_wait_for_state(saved_query_id, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      initial_get_result = @service_client.get_saved_query(saved_query_id)
      operation_result = @service_client.delete_saved_query(saved_query_id, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)

      begin
        waiter_result = initial_get_result.wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200,
          succeed_on_not_found: true
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#delete_security_recipe} and then waits for the {OCI::CloudGuard::Models::SecurityRecipe} acted upon
    # to enter the given state(s).
    #
    # @param [String] security_recipe_id The unique identifier of the security zone recipe. (`SecurityRecipe`)
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::SecurityRecipe#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#delete_security_recipe}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type nil
    def delete_security_recipe_and_wait_for_state(security_recipe_id, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      initial_get_result = @service_client.get_security_recipe(security_recipe_id)
      operation_result = @service_client.delete_security_recipe(security_recipe_id, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)

      begin
        waiter_result = initial_get_result.wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200,
          succeed_on_not_found: true
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#delete_security_zone} and then waits for the {OCI::CloudGuard::Models::SecurityZone} acted upon
    # to enter the given state(s).
    #
    # @param [String] security_zone_id The unique identifier of the security zone (`SecurityZone` resource).
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::SecurityZone#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#delete_security_zone}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type nil
    def delete_security_zone_and_wait_for_state(security_zone_id, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      initial_get_result = @service_client.get_security_zone(security_zone_id)
      operation_result = @service_client.delete_security_zone(security_zone_id, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)

      begin
        waiter_result = initial_get_result.wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200,
          succeed_on_not_found: true
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#delete_target} and then waits for the {OCI::CloudGuard::Models::Target} acted upon
    # to enter the given state(s).
    #
    # @param [String] target_id OCID of the target
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::Target#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#delete_target}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type nil
    def delete_target_and_wait_for_state(target_id, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      initial_get_result = @service_client.get_target(target_id)
      operation_result = @service_client.delete_target(target_id, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)

      begin
        waiter_result = initial_get_result.wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200,
          succeed_on_not_found: true
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#remove_compartment} and then waits for the {OCI::CloudGuard::Models::SecurityZone} acted upon
    # to enter the given state(s).
    #
    # @param [String] security_zone_id The unique identifier of the security zone (`SecurityZone` resource).
    # @param [OCI::CloudGuard::Models::RemoveCompartmentDetails] remove_compartment_details The compartment to remove from the security zone
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::SecurityZone#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#remove_compartment}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::SecurityZone}
    def remove_compartment_and_wait_for_state(security_zone_id, remove_compartment_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.remove_compartment(security_zone_id, remove_compartment_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_security_zone(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#update_data_mask_rule} and then waits for the {OCI::CloudGuard::Models::DataMaskRule} acted upon
    # to enter the given state(s).
    #
    # @param [String] data_mask_rule_id OCID of the data mask rule
    # @param [OCI::CloudGuard::Models::UpdateDataMaskRuleDetails] update_data_mask_rule_details The data mask rule information to be updated
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::DataMaskRule#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#update_data_mask_rule}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::DataMaskRule}
    def update_data_mask_rule_and_wait_for_state(data_mask_rule_id, update_data_mask_rule_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.update_data_mask_rule(data_mask_rule_id, update_data_mask_rule_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_data_mask_rule(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#update_data_source} and then waits for the {OCI::CloudGuard::Models::WorkRequest}
    # to enter the given state(s).
    #
    # @param [String] data_source_id Data source OCID.
    # @param [OCI::CloudGuard::Models::UpdateDataSourceDetails] update_data_source_details Details for the DataSource resource to be updated
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::WorkRequest#status}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#update_data_source}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object containing the completed {OCI::CloudGuard::Models::WorkRequest}
    def update_data_source_and_wait_for_state(data_source_id, update_data_source_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.update_data_source(data_source_id, update_data_source_details, base_operation_opts)
      use_util = OCI::CloudGuard::Util.respond_to?(:wait_on_work_request)

      return operation_result if wait_for_states.empty? && !use_util

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.headers['opc-work-request-id']
      return operation_result if wait_for_resource_id.nil? || wait_for_resource_id.empty?

      begin
        if use_util
          waiter_result = OCI::CloudGuard::Util.wait_on_work_request(
            @service_client,
            wait_for_resource_id,
            max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
            max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
          )
        else
          waiter_result = @service_client.get_work_request(wait_for_resource_id).wait_until(
            eval_proc: ->(response) { response.data.respond_to?(:status) && lowered_wait_for_states.include?(response.data.status.downcase) },
            max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
            max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
          )
        end
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#update_detector_recipe} and then waits for the {OCI::CloudGuard::Models::DetectorRecipe} acted upon
    # to enter the given state(s).
    #
    # @param [String] detector_recipe_id Detector recipe OCID
    # @param [OCI::CloudGuard::Models::UpdateDetectorRecipeDetails] update_detector_recipe_details Details for the DetectorRecipe to be updated
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::DetectorRecipe#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#update_detector_recipe}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::DetectorRecipe}
    def update_detector_recipe_and_wait_for_state(detector_recipe_id, update_detector_recipe_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.update_detector_recipe(detector_recipe_id, update_detector_recipe_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_detector_recipe(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#update_detector_recipe_detector_rule} and then waits for the {OCI::CloudGuard::Models::DetectorRecipeDetectorRule} acted upon
    # to enter the given state(s).
    #
    # @param [String] detector_recipe_id Detector recipe OCID
    # @param [String] detector_rule_id The unique identifier of a detector rule.
    # @param [OCI::CloudGuard::Models::UpdateDetectorRecipeDetectorRuleDetails] update_detector_recipe_detector_rule_details The details to be updated for DetectorRule
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::DetectorRecipeDetectorRule#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#update_detector_recipe_detector_rule}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::DetectorRecipeDetectorRule}
    def update_detector_recipe_detector_rule_and_wait_for_state(detector_recipe_id, detector_rule_id, update_detector_recipe_detector_rule_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.update_detector_recipe_detector_rule(detector_recipe_id, detector_rule_id, update_detector_recipe_detector_rule_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_detector_recipe_detector_rule(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#update_managed_list} and then waits for the {OCI::CloudGuard::Models::ManagedList} acted upon
    # to enter the given state(s).
    #
    # @param [String] managed_list_id The managed list OCID to be passed in the request.
    # @param [OCI::CloudGuard::Models::UpdateManagedListDetails] update_managed_list_details Details for the ManagedList resource to be updated
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::ManagedList#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#update_managed_list}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::ManagedList}
    def update_managed_list_and_wait_for_state(managed_list_id, update_managed_list_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.update_managed_list(managed_list_id, update_managed_list_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_managed_list(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#update_problem_status} and then waits for the {OCI::CloudGuard::Models::Problem} acted upon
    # to enter the given state(s).
    #
    # @param [String] problem_id OCID of the problem.
    # @param [OCI::CloudGuard::Models::UpdateProblemStatusDetails] update_problem_status_details The additional details for the problem
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::Problem#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#update_problem_status}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::Problem}
    def update_problem_status_and_wait_for_state(problem_id, update_problem_status_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.update_problem_status(problem_id, update_problem_status_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_problem(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#update_responder_recipe} and then waits for the {OCI::CloudGuard::Models::ResponderRecipe} acted upon
    # to enter the given state(s).
    #
    # @param [String] responder_recipe_id OCID of the responder recipe.
    # @param [OCI::CloudGuard::Models::UpdateResponderRecipeDetails] update_responder_recipe_details The details to be updated
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::ResponderRecipe#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#update_responder_recipe}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::ResponderRecipe}
    def update_responder_recipe_and_wait_for_state(responder_recipe_id, update_responder_recipe_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.update_responder_recipe(responder_recipe_id, update_responder_recipe_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_responder_recipe(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#update_responder_recipe_responder_rule} and then waits for the {OCI::CloudGuard::Models::ResponderRecipeResponderRule} acted upon
    # to enter the given state(s).
    #
    # @param [String] responder_recipe_id OCID of the responder recipe.
    # @param [String] responder_rule_id Unique identifier of the responder rule.
    # @param [OCI::CloudGuard::Models::UpdateResponderRecipeResponderRuleDetails] update_responder_recipe_responder_rule_details The details to be updated for responder rule
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::ResponderRecipeResponderRule#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#update_responder_recipe_responder_rule}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::ResponderRecipeResponderRule}
    def update_responder_recipe_responder_rule_and_wait_for_state(responder_recipe_id, responder_rule_id, update_responder_recipe_responder_rule_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.update_responder_recipe_responder_rule(responder_recipe_id, responder_rule_id, update_responder_recipe_responder_rule_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_responder_recipe_responder_rule(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#update_saved_query} and then waits for the {OCI::CloudGuard::Models::SavedQuery} acted upon
    # to enter the given state(s).
    #
    # @param [String] saved_query_id Saved query OCID
    # @param [OCI::CloudGuard::Models::UpdateSavedQueryDetails] update_saved_query_details Details for the SavedQuery resource to be updated
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::SavedQuery#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#update_saved_query}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::SavedQuery}
    def update_saved_query_and_wait_for_state(saved_query_id, update_saved_query_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.update_saved_query(saved_query_id, update_saved_query_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_saved_query(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#update_security_recipe} and then waits for the {OCI::CloudGuard::Models::SecurityRecipe} acted upon
    # to enter the given state(s).
    #
    # @param [String] security_recipe_id The unique identifier of the security zone recipe. (`SecurityRecipe`)
    # @param [OCI::CloudGuard::Models::UpdateSecurityRecipeDetails] update_security_recipe_details The information to be updated in the security zone recipe
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::SecurityRecipe#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#update_security_recipe}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::SecurityRecipe}
    def update_security_recipe_and_wait_for_state(security_recipe_id, update_security_recipe_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.update_security_recipe(security_recipe_id, update_security_recipe_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_security_recipe(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#update_security_zone} and then waits for the {OCI::CloudGuard::Models::SecurityZone} acted upon
    # to enter the given state(s).
    #
    # @param [String] security_zone_id The unique identifier of the security zone (`SecurityZone` resource).
    # @param [OCI::CloudGuard::Models::UpdateSecurityZoneDetails] update_security_zone_details The security zone information to be updated
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::SecurityZone#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#update_security_zone}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::SecurityZone}
    def update_security_zone_and_wait_for_state(security_zone_id, update_security_zone_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.update_security_zone(security_zone_id, update_security_zone_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_security_zone(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#update_target} and then waits for the {OCI::CloudGuard::Models::Target} acted upon
    # to enter the given state(s).
    #
    # @param [String] target_id OCID of the target
    # @param [OCI::CloudGuard::Models::UpdateTargetDetails] update_target_details The information to be updated
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::Target#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#update_target}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::Target}
    def update_target_and_wait_for_state(target_id, update_target_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.update_target(target_id, update_target_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_target(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#update_target_detector_recipe} and then waits for the {OCI::CloudGuard::Models::TargetDetectorRecipe} acted upon
    # to enter the given state(s).
    #
    # @param [String] target_id OCID of the target
    # @param [String] target_detector_recipe_id OCID of the target detector recipe.
    # @param [OCI::CloudGuard::Models::UpdateTargetDetectorRecipeDetails] update_target_detector_recipe_details The details to be updated
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::TargetDetectorRecipe#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#update_target_detector_recipe}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::TargetDetectorRecipe}
    def update_target_detector_recipe_and_wait_for_state(target_id, target_detector_recipe_id, update_target_detector_recipe_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.update_target_detector_recipe(target_id, target_detector_recipe_id, update_target_detector_recipe_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_target_detector_recipe(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#update_target_detector_recipe_detector_rule} and then waits for the {OCI::CloudGuard::Models::TargetDetectorRecipeDetectorRule} acted upon
    # to enter the given state(s).
    #
    # @param [String] target_id OCID of the target
    # @param [String] target_detector_recipe_id OCID of the target detector recipe.
    # @param [String] detector_rule_id The unique identifier of the detector rule.
    # @param [OCI::CloudGuard::Models::UpdateTargetDetectorRecipeDetectorRuleDetails] update_target_detector_recipe_detector_rule_details The details to be updated for the detector rule
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::TargetDetectorRecipeDetectorRule#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#update_target_detector_recipe_detector_rule}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::TargetDetectorRecipeDetectorRule}
    def update_target_detector_recipe_detector_rule_and_wait_for_state(target_id, target_detector_recipe_id, detector_rule_id, update_target_detector_recipe_detector_rule_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.update_target_detector_recipe_detector_rule(target_id, target_detector_recipe_id, detector_rule_id, update_target_detector_recipe_detector_rule_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_target_detector_recipe_detector_rule(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:disable Layout/EmptyLines


    # Calls {OCI::CloudGuard::CloudGuardClient#update_target_responder_recipe_responder_rule} and then waits for the {OCI::CloudGuard::Models::TargetResponderRecipeResponderRule} acted upon
    # to enter the given state(s).
    #
    # @param [String] target_id OCID of the target
    # @param [String] target_responder_recipe_id OCID of the target responder recipe.
    # @param [String] responder_rule_id Unique identifier of the responder rule.
    # @param [OCI::CloudGuard::Models::UpdateTargetResponderRecipeResponderRuleDetails] update_target_responder_recipe_responder_rule_details The details to be updated for the ResponderRule resource.
    # @param [Array<String>] wait_for_states An array of states to wait on. These should be valid values for {OCI::CloudGuard::Models::TargetResponderRecipeResponderRule#lifecycle_state}
    # @param [Hash] base_operation_opts Any optional arguments accepted by {OCI::CloudGuard::CloudGuardClient#update_target_responder_recipe_responder_rule}
    # @param [Hash] waiter_opts Optional arguments for the waiter. Keys should be symbols, and the following keys are supported:
    #   * max_interval_seconds: The maximum interval between queries, in seconds.
    #   * max_wait_seconds The maximum time to wait, in seconds
    #
    # @return [OCI::Response] A {OCI::Response} object with data of type {OCI::CloudGuard::Models::TargetResponderRecipeResponderRule}
    def update_target_responder_recipe_responder_rule_and_wait_for_state(target_id, target_responder_recipe_id, responder_rule_id, update_target_responder_recipe_responder_rule_details, wait_for_states = [], base_operation_opts = {}, waiter_opts = {})
      operation_result = @service_client.update_target_responder_recipe_responder_rule(target_id, target_responder_recipe_id, responder_rule_id, update_target_responder_recipe_responder_rule_details, base_operation_opts)

      return operation_result if wait_for_states.empty?

      lowered_wait_for_states = wait_for_states.map(&:downcase)
      wait_for_resource_id = operation_result.data.id

      begin
        waiter_result = @service_client.get_target_responder_recipe_responder_rule(wait_for_resource_id).wait_until(
          eval_proc: ->(response) { response.data.respond_to?(:lifecycle_state) && lowered_wait_for_states.include?(response.data.lifecycle_state.downcase) },
          max_interval_seconds: waiter_opts.key?(:max_interval_seconds) ? waiter_opts[:max_interval_seconds] : 30,
          max_wait_seconds: waiter_opts.key?(:max_wait_seconds) ? waiter_opts[:max_wait_seconds] : 1200
        )
        result_to_return = waiter_result

        return result_to_return
      rescue StandardError
        raise OCI::Errors::CompositeOperationError.new(partial_results: [operation_result])
      end
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/ParameterLists, Metrics/PerceivedComplexity
    # rubocop:enable Layout/EmptyLines
  end
end
# rubocop:enable Lint/UnneededCopDisableDirective, Metrics/LineLength
