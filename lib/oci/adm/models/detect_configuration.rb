# Copyright (c) 2016, 2024, Oracle and/or its affiliates.  All rights reserved.
# This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.

# NOTE: This class is auto generated by OracleSDKGenerator. DO NOT EDIT. API Version: 20220421
require 'date'
require 'logger'

# rubocop:disable Lint/UnneededCopDisableDirective, Metrics/LineLength
module OCI
  # A configuration to define the constraints when detecting vulnerable dependencies.
  #
  class Adm::Models::DetectConfiguration
    UPGRADE_POLICY_ENUM = [
      UPGRADE_POLICY_NEAREST = 'NEAREST'.freeze,
      UPGRADE_POLICY_UNKNOWN_ENUM_VALUE = 'UNKNOWN_ENUM_VALUE'.freeze
    ].freeze

    MAX_PERMISSIBLE_SEVERITY_ENUM = [
      MAX_PERMISSIBLE_SEVERITY_UNSET = 'UNSET'.freeze,
      MAX_PERMISSIBLE_SEVERITY_NONE = 'NONE'.freeze,
      MAX_PERMISSIBLE_SEVERITY_LOW = 'LOW'.freeze,
      MAX_PERMISSIBLE_SEVERITY_MEDIUM = 'MEDIUM'.freeze,
      MAX_PERMISSIBLE_SEVERITY_HIGH = 'HIGH'.freeze,
      MAX_PERMISSIBLE_SEVERITY_CRITICAL = 'CRITICAL'.freeze,
      MAX_PERMISSIBLE_SEVERITY_UNKNOWN_ENUM_VALUE = 'UNKNOWN_ENUM_VALUE'.freeze
    ].freeze

    # The list of dependencies to be ignored by the recommendation algorithm. The dependency pattern is matched against the 'group:artifact:version' or the purl of a dependency.
    # An asterisk (*) at the end in the dependency pattern acts as a wildcard and matches zero or more characters.
    #
    # @return [Array<String>]
    attr_accessor :exclusions

    # The upgrade policy for recommendations.
    # The `Nearest` upgrade policy upgrades a dependency to the oldest version that meets both of the following criteria: it is newer than the current version and it is not affected by a vulnerability.
    #
    # @return [String]
    attr_reader :upgrade_policy

    # The maximum Common Vulnerability Scoring System Version 2 (CVSS V2) score. An artifact with a CVSS V2 score below this value is not considered for patching.
    # @return [Float]
    attr_accessor :max_permissible_cvss_v2_score

    # The maximum Common Vulnerability Scoring System Version 3 (CVSS V3) score. An artifact with a CVSS V3 score below this value is not considered for patching.
    # @return [Float]
    attr_accessor :max_permissible_cvss_v3_score

    # The maximum ADM Severity. An artifact with an ADM Severity below this value is not considered for patching.
    # @return [String]
    attr_reader :max_permissible_severity

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        # rubocop:disable Style/SymbolLiteral
        'exclusions': :'exclusions',
        'upgrade_policy': :'upgradePolicy',
        'max_permissible_cvss_v2_score': :'maxPermissibleCvssV2Score',
        'max_permissible_cvss_v3_score': :'maxPermissibleCvssV3Score',
        'max_permissible_severity': :'maxPermissibleSeverity'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        # rubocop:disable Style/SymbolLiteral
        'exclusions': :'Array<String>',
        'upgrade_policy': :'String',
        'max_permissible_cvss_v2_score': :'Float',
        'max_permissible_cvss_v3_score': :'Float',
        'max_permissible_severity': :'String'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:disable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral


    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    # @option attributes [Array<String>] :exclusions The value to assign to the {#exclusions} property
    # @option attributes [String] :upgrade_policy The value to assign to the {#upgrade_policy} property
    # @option attributes [Float] :max_permissible_cvss_v2_score The value to assign to the {#max_permissible_cvss_v2_score} property
    # @option attributes [Float] :max_permissible_cvss_v3_score The value to assign to the {#max_permissible_cvss_v3_score} property
    # @option attributes [String] :max_permissible_severity The value to assign to the {#max_permissible_severity} property
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

      self.exclusions = attributes[:'exclusions'] if attributes[:'exclusions']

      self.upgrade_policy = attributes[:'upgradePolicy'] if attributes[:'upgradePolicy']

      raise 'You cannot provide both :upgradePolicy and :upgrade_policy' if attributes.key?(:'upgradePolicy') && attributes.key?(:'upgrade_policy')

      self.upgrade_policy = attributes[:'upgrade_policy'] if attributes[:'upgrade_policy']

      self.max_permissible_cvss_v2_score = attributes[:'maxPermissibleCvssV2Score'] if attributes[:'maxPermissibleCvssV2Score']
      self.max_permissible_cvss_v2_score = 0.0 if max_permissible_cvss_v2_score.nil? && !attributes.key?(:'maxPermissibleCvssV2Score') # rubocop:disable Style/StringLiterals

      raise 'You cannot provide both :maxPermissibleCvssV2Score and :max_permissible_cvss_v2_score' if attributes.key?(:'maxPermissibleCvssV2Score') && attributes.key?(:'max_permissible_cvss_v2_score')

      self.max_permissible_cvss_v2_score = attributes[:'max_permissible_cvss_v2_score'] if attributes[:'max_permissible_cvss_v2_score']
      self.max_permissible_cvss_v2_score = 0.0 if max_permissible_cvss_v2_score.nil? && !attributes.key?(:'maxPermissibleCvssV2Score') && !attributes.key?(:'max_permissible_cvss_v2_score') # rubocop:disable Style/StringLiterals

      self.max_permissible_cvss_v3_score = attributes[:'maxPermissibleCvssV3Score'] if attributes[:'maxPermissibleCvssV3Score']
      self.max_permissible_cvss_v3_score = 0.0 if max_permissible_cvss_v3_score.nil? && !attributes.key?(:'maxPermissibleCvssV3Score') # rubocop:disable Style/StringLiterals

      raise 'You cannot provide both :maxPermissibleCvssV3Score and :max_permissible_cvss_v3_score' if attributes.key?(:'maxPermissibleCvssV3Score') && attributes.key?(:'max_permissible_cvss_v3_score')

      self.max_permissible_cvss_v3_score = attributes[:'max_permissible_cvss_v3_score'] if attributes[:'max_permissible_cvss_v3_score']
      self.max_permissible_cvss_v3_score = 0.0 if max_permissible_cvss_v3_score.nil? && !attributes.key?(:'maxPermissibleCvssV3Score') && !attributes.key?(:'max_permissible_cvss_v3_score') # rubocop:disable Style/StringLiterals

      self.max_permissible_severity = attributes[:'maxPermissibleSeverity'] if attributes[:'maxPermissibleSeverity']

      raise 'You cannot provide both :maxPermissibleSeverity and :max_permissible_severity' if attributes.key?(:'maxPermissibleSeverity') && attributes.key?(:'max_permissible_severity')

      self.max_permissible_severity = attributes[:'max_permissible_severity'] if attributes[:'max_permissible_severity']
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:enable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] upgrade_policy Object to be assigned
    def upgrade_policy=(upgrade_policy)
      # rubocop:disable Style/ConditionalAssignment
      if upgrade_policy && !UPGRADE_POLICY_ENUM.include?(upgrade_policy)
        OCI.logger.debug("Unknown value for 'upgrade_policy' [" + upgrade_policy + "]. Mapping to 'UPGRADE_POLICY_UNKNOWN_ENUM_VALUE'") if OCI.logger
        @upgrade_policy = UPGRADE_POLICY_UNKNOWN_ENUM_VALUE
      else
        @upgrade_policy = upgrade_policy
      end
      # rubocop:enable Style/ConditionalAssignment
    end

    # Custom attribute writer method checking allowed values (enum).
    # @param [Object] max_permissible_severity Object to be assigned
    def max_permissible_severity=(max_permissible_severity)
      # rubocop:disable Style/ConditionalAssignment
      if max_permissible_severity && !MAX_PERMISSIBLE_SEVERITY_ENUM.include?(max_permissible_severity)
        OCI.logger.debug("Unknown value for 'max_permissible_severity' [" + max_permissible_severity + "]. Mapping to 'MAX_PERMISSIBLE_SEVERITY_UNKNOWN_ENUM_VALUE'") if OCI.logger
        @max_permissible_severity = MAX_PERMISSIBLE_SEVERITY_UNKNOWN_ENUM_VALUE
      else
        @max_permissible_severity = max_permissible_severity
      end
      # rubocop:enable Style/ConditionalAssignment
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines


    # Checks equality by comparing each attribute.
    # @param [Object] other the other object to be compared
    def ==(other)
      return true if equal?(other)

      self.class == other.class &&
        exclusions == other.exclusions &&
        upgrade_policy == other.upgrade_policy &&
        max_permissible_cvss_v2_score == other.max_permissible_cvss_v2_score &&
        max_permissible_cvss_v3_score == other.max_permissible_cvss_v3_score &&
        max_permissible_severity == other.max_permissible_severity
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines

    # @see the `==` method
    # @param [Object] other the other object to be compared
    def eql?(other)
      self == other
    end

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [exclusions, upgrade_policy, max_permissible_cvss_v2_score, max_permissible_cvss_v3_score, max_permissible_severity].hash
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)

      self.class.swagger_types.each_pair do |key, type|
        if type =~ /^Array<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            public_method("#{key}=").call(
              attributes[self.class.attribute_map[key]]
                .map { |v| OCI::Internal::Util.convert_to_type(Regexp.last_match(1), v) }
            )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          public_method("#{key}=").call(
            OCI::Internal::Util.convert_to_type(type, attributes[self.class.attribute_map[key]])
          )
        end
        # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = public_method(attr).call
        next if value.nil? && !instance_variable_defined?("@#{attr}")

        hash[param] = _to_hash(value)
      end
      hash
    end

    private

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
# rubocop:enable Lint/UnneededCopDisableDirective, Metrics/LineLength
