# Copyright (c) 2016, 2024, Oracle and/or its affiliates.  All rights reserved.
# This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.

# NOTE: This class is auto generated by OracleSDKGenerator. DO NOT EDIT. API Version: 20181201
require 'date'

# rubocop:disable Lint/UnneededCopDisableDirective, Metrics/LineLength
module OCI
  # Summary of audit log of risk updates of findings of specified security assessment.
  class DataSafe::Models::FindingsChangeAuditLogSummary
    # **[Required]** The unique key that identifies the finding risk change.
    # @return [String]
    attr_accessor :key

    # **[Required]** The unique key that identifies the finding.
    # @return [String]
    attr_accessor :finding_key

    # **[Required]** The short title for the finding whose risk is being modified.
    # @return [String]
    attr_accessor :finding_title

    # **[Required]** The OCID of the latest security assessment.
    # @return [String]
    attr_accessor :assessment_id

    # **[Required]** The OCID of the target database.
    # @return [String]
    attr_accessor :target_id

    # **[Required]** The date and time the risk level of finding was last updated, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339).
    #
    # @return [DateTime]
    attr_accessor :time_updated

    # **[Required]** The original severity / risk level of the finding as determined by security assessment.
    # @return [String]
    attr_accessor :severity

    # **[Required]** The severity of the finding as determined by security assessment by Oracle.
    # @return [String]
    attr_accessor :oracle_defined_severity

    # **[Required]** Determines if the user has deferred the risk level of this finding when he is ok with it
    # and does not plan to do anything about it.
    #
    # @return [BOOLEAN]
    attr_accessor :is_risk_deferred

    # **[Required]** If the risk level is changed more than once, the previous modified value.
    # @return [String]
    attr_accessor :previous_severity

    # **[Required]** The justification given by the user for accepting or modifying the risk level.
    # @return [String]
    attr_accessor :justification

    # The date and time, in the format defined by [RFC3339](https://tools.ietf.org/html/rfc3339),
    # the risk level change as updated by user is valid until. After this date passes, the risk level
    # will be that of what is determined by the latest security assessment.
    #
    # @return [DateTime]
    attr_accessor :time_valid_until

    # **[Required]** The user who initiated change of risk level of the finding
    # @return [String]
    attr_accessor :modified_by

    # Attribute mapping from ruby-style variable name to JSON key.
    def self.attribute_map
      {
        # rubocop:disable Style/SymbolLiteral
        'key': :'key',
        'finding_key': :'findingKey',
        'finding_title': :'findingTitle',
        'assessment_id': :'assessmentId',
        'target_id': :'targetId',
        'time_updated': :'timeUpdated',
        'severity': :'severity',
        'oracle_defined_severity': :'oracleDefinedSeverity',
        'is_risk_deferred': :'isRiskDeferred',
        'previous_severity': :'previousSeverity',
        'justification': :'justification',
        'time_valid_until': :'timeValidUntil',
        'modified_by': :'modifiedBy'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # Attribute type mapping.
    def self.swagger_types
      {
        # rubocop:disable Style/SymbolLiteral
        'key': :'String',
        'finding_key': :'String',
        'finding_title': :'String',
        'assessment_id': :'String',
        'target_id': :'String',
        'time_updated': :'DateTime',
        'severity': :'String',
        'oracle_defined_severity': :'String',
        'is_risk_deferred': :'BOOLEAN',
        'previous_severity': :'String',
        'justification': :'String',
        'time_valid_until': :'DateTime',
        'modified_by': :'String'
        # rubocop:enable Style/SymbolLiteral
      }
    end

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:disable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral


    # Initializes the object
    # @param [Hash] attributes Model attributes in the form of hash
    # @option attributes [String] :key The value to assign to the {#key} property
    # @option attributes [String] :finding_key The value to assign to the {#finding_key} property
    # @option attributes [String] :finding_title The value to assign to the {#finding_title} property
    # @option attributes [String] :assessment_id The value to assign to the {#assessment_id} property
    # @option attributes [String] :target_id The value to assign to the {#target_id} property
    # @option attributes [DateTime] :time_updated The value to assign to the {#time_updated} property
    # @option attributes [String] :severity The value to assign to the {#severity} property
    # @option attributes [String] :oracle_defined_severity The value to assign to the {#oracle_defined_severity} property
    # @option attributes [BOOLEAN] :is_risk_deferred The value to assign to the {#is_risk_deferred} property
    # @option attributes [String] :previous_severity The value to assign to the {#previous_severity} property
    # @option attributes [String] :justification The value to assign to the {#justification} property
    # @option attributes [DateTime] :time_valid_until The value to assign to the {#time_valid_until} property
    # @option attributes [String] :modified_by The value to assign to the {#modified_by} property
    def initialize(attributes = {})
      return unless attributes.is_a?(Hash)

      # convert string to symbol for hash key
      attributes = attributes.each_with_object({}) { |(k, v), h| h[k.to_sym] = v }

      self.key = attributes[:'key'] if attributes[:'key']

      self.finding_key = attributes[:'findingKey'] if attributes[:'findingKey']

      raise 'You cannot provide both :findingKey and :finding_key' if attributes.key?(:'findingKey') && attributes.key?(:'finding_key')

      self.finding_key = attributes[:'finding_key'] if attributes[:'finding_key']

      self.finding_title = attributes[:'findingTitle'] if attributes[:'findingTitle']

      raise 'You cannot provide both :findingTitle and :finding_title' if attributes.key?(:'findingTitle') && attributes.key?(:'finding_title')

      self.finding_title = attributes[:'finding_title'] if attributes[:'finding_title']

      self.assessment_id = attributes[:'assessmentId'] if attributes[:'assessmentId']

      raise 'You cannot provide both :assessmentId and :assessment_id' if attributes.key?(:'assessmentId') && attributes.key?(:'assessment_id')

      self.assessment_id = attributes[:'assessment_id'] if attributes[:'assessment_id']

      self.target_id = attributes[:'targetId'] if attributes[:'targetId']

      raise 'You cannot provide both :targetId and :target_id' if attributes.key?(:'targetId') && attributes.key?(:'target_id')

      self.target_id = attributes[:'target_id'] if attributes[:'target_id']

      self.time_updated = attributes[:'timeUpdated'] if attributes[:'timeUpdated']

      raise 'You cannot provide both :timeUpdated and :time_updated' if attributes.key?(:'timeUpdated') && attributes.key?(:'time_updated')

      self.time_updated = attributes[:'time_updated'] if attributes[:'time_updated']

      self.severity = attributes[:'severity'] if attributes[:'severity']

      self.oracle_defined_severity = attributes[:'oracleDefinedSeverity'] if attributes[:'oracleDefinedSeverity']

      raise 'You cannot provide both :oracleDefinedSeverity and :oracle_defined_severity' if attributes.key?(:'oracleDefinedSeverity') && attributes.key?(:'oracle_defined_severity')

      self.oracle_defined_severity = attributes[:'oracle_defined_severity'] if attributes[:'oracle_defined_severity']

      self.is_risk_deferred = attributes[:'isRiskDeferred'] unless attributes[:'isRiskDeferred'].nil?

      raise 'You cannot provide both :isRiskDeferred and :is_risk_deferred' if attributes.key?(:'isRiskDeferred') && attributes.key?(:'is_risk_deferred')

      self.is_risk_deferred = attributes[:'is_risk_deferred'] unless attributes[:'is_risk_deferred'].nil?

      self.previous_severity = attributes[:'previousSeverity'] if attributes[:'previousSeverity']

      raise 'You cannot provide both :previousSeverity and :previous_severity' if attributes.key?(:'previousSeverity') && attributes.key?(:'previous_severity')

      self.previous_severity = attributes[:'previous_severity'] if attributes[:'previous_severity']

      self.justification = attributes[:'justification'] if attributes[:'justification']

      self.time_valid_until = attributes[:'timeValidUntil'] if attributes[:'timeValidUntil']

      raise 'You cannot provide both :timeValidUntil and :time_valid_until' if attributes.key?(:'timeValidUntil') && attributes.key?(:'time_valid_until')

      self.time_valid_until = attributes[:'time_valid_until'] if attributes[:'time_valid_until']

      self.modified_by = attributes[:'modifiedBy'] if attributes[:'modifiedBy']

      raise 'You cannot provide both :modifiedBy and :modified_by' if attributes.key?(:'modifiedBy') && attributes.key?(:'modified_by')

      self.modified_by = attributes[:'modified_by'] if attributes[:'modified_by']
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity
    # rubocop:enable Metrics/MethodLength, Layout/EmptyLines, Style/SymbolLiteral

    # rubocop:disable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines


    # Checks equality by comparing each attribute.
    # @param [Object] other the other object to be compared
    def ==(other)
      return true if equal?(other)

      self.class == other.class &&
        key == other.key &&
        finding_key == other.finding_key &&
        finding_title == other.finding_title &&
        assessment_id == other.assessment_id &&
        target_id == other.target_id &&
        time_updated == other.time_updated &&
        severity == other.severity &&
        oracle_defined_severity == other.oracle_defined_severity &&
        is_risk_deferred == other.is_risk_deferred &&
        previous_severity == other.previous_severity &&
        justification == other.justification &&
        time_valid_until == other.time_valid_until &&
        modified_by == other.modified_by
    end
    # rubocop:enable Metrics/CyclomaticComplexity, Metrics/AbcSize, Metrics/PerceivedComplexity, Layout/EmptyLines

    # @see the `==` method
    # @param [Object] other the other object to be compared
    def eql?(other)
      self == other
    end

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Calculates hash code according to all attributes.
    # @return [Fixnum] Hash code
    def hash
      [key, finding_key, finding_title, assessment_id, target_id, time_updated, severity, oracle_defined_severity, is_risk_deferred, previous_severity, justification, time_valid_until, modified_by].hash
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # rubocop:disable Metrics/AbcSize, Layout/EmptyLines


    # Builds the object from hash
    # @param [Hash] attributes Model attributes in the form of hash
    # @return [Object] Returns the model itself
    def build_from_hash(attributes)
      return nil unless attributes.is_a?(Hash)

      self.class.swagger_types.each_pair do |key, type|
        if type =~ /^Array<(.*)>/i
          # check to ensure the input is an array given that the the attribute
          # is documented as an array but the input is not
          if attributes[self.class.attribute_map[key]].is_a?(Array)
            public_method("#{key}=").call(
              attributes[self.class.attribute_map[key]]
                .map { |v| OCI::Internal::Util.convert_to_type(Regexp.last_match(1), v) }
            )
          end
        elsif !attributes[self.class.attribute_map[key]].nil?
          public_method("#{key}=").call(
            OCI::Internal::Util.convert_to_type(type, attributes[self.class.attribute_map[key]])
          )
        end
        # or else data not found in attributes(hash), not an issue as the data can be optional
      end

      self
    end
    # rubocop:enable Metrics/AbcSize, Layout/EmptyLines

    # Returns the string representation of the object
    # @return [String] String presentation of the object
    def to_s
      to_hash.to_s
    end

    # Returns the object in the form of hash
    # @return [Hash] Returns the object in the form of hash
    def to_hash
      hash = {}
      self.class.attribute_map.each_pair do |attr, param|
        value = public_method(attr).call
        next if value.nil? && !instance_variable_defined?("@#{attr}")

        hash[param] = _to_hash(value)
      end
      hash
    end

    private

    # Outputs non-array value in the form of hash
    # For object, use to_hash. Otherwise, just return the value
    # @param [Object] value Any valid value
    # @return [Hash] Returns the value in the form of hash
    def _to_hash(value)
      if value.is_a?(Array)
        value.compact.map { |v| _to_hash(v) }
      elsif value.is_a?(Hash)
        {}.tap do |hash|
          value.each { |k, v| hash[k] = _to_hash(v) }
        end
      elsif value.respond_to? :to_hash
        value.to_hash
      else
        value
      end
    end
  end
end
# rubocop:enable Lint/UnneededCopDisableDirective, Metrics/LineLength
