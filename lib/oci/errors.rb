# Copyright (c) 2016, 2024, Oracle and/or its affiliates.  All rights reserved.
# This software is dual-licensed to you under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl or Apache License 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose either license.

module OCI
  module Errors
    # Represents an error which was generated somewhere during the process of making a HTTP request to an
    # OCI service. This error contains the raw request and also exposes some convenience properties such
    # as the opc-request-id for the request. This error makes no guarantee or inference about whether the
    # error was generated based on a response from an OCI service, whether there was a network issue etc.
    #
    # When used directly, the {#cause} of the error should be inspected for the original error which resulted
    # in this one being thrown.
    #
    # Subclasses, such as {OCI::Errors::ServiceError} and {OCI::Errors::NetworkError}, may have stronger
    # definitions around what circumstances caused the error to be thrown.
    class HttpRequestBasedError < StandardError
      # The request which was made
      #
      # @return [Net::HTTPRequest]
      attr_reader :request_made

      # The request ID from the opc-request-id header. This could be the request ID returned from the service
      # or, if there was no opc-request-id in the response, it will be the opc-request-id set client-side by the
      # caller or the SDK (if there was no explicit caller-provided opc-request-id)
      #
      # @return [String]
      attr_reader :request_id

      # The error message
      #
      # @return [String]
      attr_reader :message

      def initialize(message: nil, request_made: nil)
        # We need to mask the message attribute here as otherwise we use StandardError's
        # implementation, which calls to_s and so referencing "message" in our to_s in
        # this class (and subclasses) would go into an infinite loop
        @message = message

        @request_made = request_made
        @request_id = @request_made['opc-request-id'] unless @request_made.nil?
      end

      def to_s
        "{ 'message': '#{message}', 'opc-request-id': '#{request_id}' }"
      end
    end

    # The base error for all requests that return error responses from the service.
    class ServiceError < HttpRequestBasedError
      # HTTP status code (such as 200 or 404)
      #
      # @return [Integer]
      attr_reader :status_code

      # A service-specific error code
      #
      # @return [String]
      attr_reader :service_code

      def initialize(status_code, service_code, request_id, message, request_made: nil)
        @message = if message.nil? || message.strip.empty?
                     "The service returned error code #{status_code}"
                   else
                     message.strip
                   end
        super(message: @message, request_made: request_made)

        @status_code = status_code
        @service_code = service_code
        @request_id = request_id
      end

      def to_s
        "{ 'message': '#{message}', 'status': #{status_code}, " \
        "'code': '#{service_code}', 'opc-request-id': '#{request_id}' }"
      end
    end

    # The base error for issues which are likely to be network related, rather than an application
    # issue. This is defined as:
    #
    #   * Requests which were sent from the SDK but the outcome was not a response from an OCI service. Further examples of include:
    #     * Gateway timeouts
    #     * Read or connection timeouts
    #     * Any {Errno} exception which was generated by making the request
    #   * Requests which resulted in a HTTP 408 (timeout)
    #
    # The {#cause} of this error can be inspected to see if there was an original error which resulted in this one being thrown.
    class NetworkError < HttpRequestBasedError
      # Error code, which is mapped to Net::HTTPResponse's code.to_i or 0 if the issue was reported by an exception.
      #
      # @return [Integer]
      attr_reader :code

      # The response received for the request, if any
      #
      # @return [Net::HTTPResponse]
      attr_reader :response_received

      def initialize(message, code, request_made: nil, response_received: nil)
        super(message: message, request_made: request_made)
        @code = code
        @response_received = response_received

        # If we have a request ID from the response then use that, otherwise just take the one from the
        # request (the superclass constructor sets the opc-request-id from the request by default)
        response_req_id = @response_received['opc-request-id'] unless @response_received.nil?
        @request_id = response_req_id unless response_req_id.nil?
      end

      def to_s
        response_body = response_received.body unless response_received.nil?

        "{ 'message': '#{message}', 'status': #{code}, " \
        "'opc-request-id': '#{request_id}', 'response-body': '#{response_body}' }"
      end
    end

    # The base error for issues related to parsing the response received from the service. The {#response_body}
    # can be inspected for the data which failed to parse and the {#cause} of this error can be inspected for the
    # underlying parsing error which occurred
    class ResponseParsingError < HttpRequestBasedError
      # The response received for the request, and whose body we failed to parse
      #
      # @return [Net::HTTPResponse]
      attr_reader :response_received

      def initialize(message: 'Failed to parse response', request_made:, response_received:)
        raise 'A message must be provided' if message.nil? || message.strip.empty?
        raise 'The request made must be provided' if request_made.nil?
        raise 'The response received must be provided' if response_received.nil?

        super(message: message, request_made: request_made)
        @response_received = response_received
        @request_id = @response_received['opc-request-id'] unless @response_received['opc-request-id'].nil?
      end

      # The response body which we failed to parse
      #
      # @return [String]
      def response_body
        response_received.body
      end

      # The status code of the response (e.g. 200)
      #
      # @return [Integer]
      def status_code
        response_received.code.to_i
      end

      def to_s
        "{ 'message': '#{message}', 'status': #{status_code}, " \
        "'opc-request-id': '#{request_id}', 'response-body': '#{response_body}' }"
      end
    end

    # Raised when the maximum wait time is exceeded.
    class MaximumWaitTimeExceededError < StandardError; end

    # Raised when a work request returns as failed while waiting on completion.
    class WorkRequestFailedError < StandardError
      # The failed work request.
      attr_reader :work_request

      # The status associated with the failed work request.
      attr_reader :status

      def initialize(work_request, status)
        # TODO: May also want to include error_details.
        super "Work request failed. ID: #{work_request.id}, Status: #{status}"
        @work_request = work_request
        @status = status
      end
    end

    # Raised when a work request returns as canceled while waiting on completion.
    class WorkRequestCanceledError < StandardError
      # The failed work request.
      attr_reader :work_request

      # The status associated with the failed work request.
      attr_reader :status

      def initialize(work_request, status)
        super "Work request canceled. ID: #{work_request.id}, Status: #{status}"
        @work_request = work_request
        @status = status
      end
    end

    # Raised when there is an error performing a multipart upload (either a new upload or resuming
    # an existing upload).
    class MultipartUploadError < StandardError
      # An array containing the underlying errors which caused the failure
      # @return [Array]
      attr_reader :errors

      # The ID of multipart upload against which the error occurred, if known. This may be useful for
      # resuming uploads which failed because of intermittent issues (e.g. network connectivity or
      # HTTP 5xx errors received from the service)
      # @return [String]
      attr_reader :upload_id

      def initialize(message, errors = [], upload_id = nil)
        super(message)
        @errors = errors
        @upload_id = upload_id
      end
    end

    # This error is used by the CompositeOperation classes to flag when part of an operation succeeded. For
    # example, creating a resource succeeded but waiting for it to move into a given state failed. This
    # error will contain any results of the composite operation which are available.
    #
    # The {#cause} of the error should be inspected for the original error which resulted
    # in this one being thrown.
    class CompositeOperationError < StandardError
      # An array containing any successful {OCI::Response} from the composite operation
      # @return [Array<Response>]
      attr_reader :partial_results

      def initialize(partial_results:)
        @partial_results = partial_results
      end
    end
  end
end
